import { constants } from "fs";
import * as fs from "fs/promises";
import * as os from "os";
import * as path from "path";
import { resolve } from "path";
import Arborist from "@npmcli/arborist";
import { BuiltinPlatform } from "@winglang/compiler";
import { minimatch } from "minimatch";
import packlist from "npm-packlist";
import * as tar from "tar";
import { compile } from "./compile";

// TODO: add --dry-run option?
// TODO: let the user specify library's supported targets in package.json, and compile to each before packaging
// TODO: print information about the generated library? (e.g. size, dependencies, number of public APIs)

export interface PackageOptions {
  /**
   * Output filename.
   */
  readonly outfile?: string;
}

export async function pack(options: PackageOptions = {}): Promise<string> {
  // check that the library compiles to the "sim" target
  console.log('Compiling to the "sim" target...');

  // TODO: workaround for https://github.com/winglang/wing/issues/4431
  // await compile(".", { target: Target.SIM });
  await compile(path.join("..", path.basename(process.cwd())), { platform: [BuiltinPlatform.SIM] });

  const userDir = process.cwd();
  const outfile = options.outfile ? resolve(options.outfile) : undefined;
  const outdir = outfile ? path.dirname(outfile) : userDir;

  // check package.json exists
  const originalPkgJsonPath = path.join(userDir, "package.json");
  if (!(await exists(originalPkgJsonPath))) {
    throw new Error(`No package.json found in the current directory. Run \`npm init\` first.`);
  }

  const originalPkgJson = JSON.parse(await fs.readFile(originalPkgJsonPath, "utf8"));
  const originalPkgJsonFiles: Set<string> = new Set(originalPkgJson.files ?? []);

  // perform our work in a staging directory to avoid making a mess in the user's current directory
  return withTempDir(async (workdir) => {
    const excludeGlobs = ["/target/**", "/node_modules/**", "/.git/**", "/.wing/**"];
    const includeGlobs = [
      ...originalPkgJsonFiles,
      "README*",
      "package.json",
      "**/*.w",
      "**/*.js",
      "LICENSE*",
    ];

    // copy the user's directory to the staging directory
    await copyDir(userDir, workdir, excludeGlobs, includeGlobs);

    // check package.json exists
    const pkgJsonPath = path.join(workdir, "package.json");
    if (!(await exists(pkgJsonPath))) {
      throw new Error(`No package.json found in the current directory. Run \`npm init\` first.`);
    }

    const pkgJson = JSON.parse(await fs.readFile(pkgJsonPath, "utf8"));

    // check package.json has required fields
    const requiredFields = ["name", "version", "description", "author", "license"];
    for (const field of requiredFields) {
      if (pkgJson[field] === undefined) {
        throw new Error(`Missing required field "${field}" in package.json.`);
      }
    }

    // check that Wing source files will be included in the tarball
    const pkgJsonFiles = new Set(pkgJson.files ?? []);
    const expectedGlobs = ["**/*.js", "**/*.w"];
    for (const glob of expectedGlobs) {
      if (!pkgJsonFiles.has(glob)) {
        pkgJsonFiles.add(glob);
      }
    }
    pkgJson.files = [...pkgJsonFiles];

    // check if "main" points to a valid file, and if not, create a dummy file
    let main = pkgJson.main ?? "index.js";
    if (!(await exists(main))) {
      const lines = [];
      lines.push("// This file was generated by `wing pack`");
      lines.push(
        `console.log("${pkgJson.name} is a winglang library and cannot be used from javascript (yet). See winglang.io/docs/libraries")`
      );
      lines.push();
      await fs.writeFile(main, lines.join("\n"));
    }
    pkgJson.main = main;

    // add "winglang" to "keywords"
    const keywords = new Set(pkgJson.keywords ?? []);
    keywords.add("winglang");
    pkgJson.keywords = [...keywords];

    // add "wing" to "engines"
    pkgJson.engines = { wing: "*" };

    // add "wing" top-level field
    pkgJson.wing = true;

    // write package.json
    await fs.writeFile(pkgJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");

    // make the tarball
    const arborist = new Arborist({ path: workdir });
    const tree = await arborist.loadActual();
    const pkg = tree.package;
    const tarballPath = outfile ?? path.join(outdir, `${pkg.name}-${pkg.version}.tgz`);
    const files = await packlist(tree);
    await tar.create(
      {
        gzip: true,
        file: tarballPath,
        cwd: workdir,
        prefix: "package/",
        portable: true,
        noPax: true,
      },
      files
    );

    console.log("Created tarball:", tarballPath);
    return tarballPath;
  });
}

async function copyDir(src: string, dest: string, excludeGlobs: string[], includeGlobs: string[]) {
  const files = await fs.readdir(src);
  for (const file of files) {
    const srcPath = path.join(src, file);
    const destPath = path.join(dest, file);
    const stat = await fs.stat(srcPath);
    if (stat.isDirectory()) {
      if (shouldInclude(srcPath, excludeGlobs, includeGlobs)) {
        await copyDir(srcPath, destPath, excludeGlobs, includeGlobs);
      }
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

function shouldInclude(srcPath: string, excludeGlobs: string[], includeGlobs: string[]): boolean {
  for (const glob of excludeGlobs) {
    if (minimatch(srcPath, glob)) {
      return false;
    }
  }
  for (const glob of includeGlobs) {
    if (minimatch(srcPath, glob)) {
      return true;
    }
  }
  return false;
}

/**
 * Run some work in a temporary directory.
 */
async function withTempDir<T>(work: (workdir: string) => Promise<T>): Promise<T> {
  const workdir = await fs.mkdtemp(path.join(os.tmpdir(), "wing-pack-"));
  const cwd = process.cwd();
  try {
    process.chdir(workdir);
    // wait for the work to be completed before
    // we cleanup the work environment.
    return await work(workdir);
  } finally {
    process.chdir(cwd);
    await fs.rm(workdir, { recursive: true });
  }
}

/**
 * Check if a file exists for an specific path
 */
export async function exists(filePath: string): Promise<boolean> {
  try {
    await fs.access(
      filePath,
      constants.F_OK | constants.R_OK | constants.W_OK //eslint-disable-line no-bitwise
    );
    return true;
  } catch (er) {
    return false;
  }
}
