// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`default website behavior 1`] = `
"{
  \\"output\\": {
    \\"WING_TEST_RUNNER_FUNCTION_ARNS\\": {
      \\"value\\": \\"[]\\"
    }
  },
  \\"resource\\": {
    \\"aws_cloudfront_distribution\\": {
      \\"root_Website_Distribution_02AE6540\\": {
        \\"default_cache_behavior\\": {
          \\"allowed_methods\\": [
            \\"GET\\",
            \\"HEAD\\"
          ],
          \\"cached_methods\\": [
            \\"GET\\",
            \\"HEAD\\"
          ],
          \\"compress\\": true,
          \\"default_ttl\\": 3600,
          \\"forwarded_values\\": {
            \\"cookies\\": {
              \\"forward\\": \\"none\\"
            },
            \\"query_string\\": false
          },
          \\"max_ttl\\": 86400,
          \\"min_ttl\\": 0,
          \\"target_origin_id\\": \\"s3Origin\\",
          \\"viewer_protocol_policy\\": \\"redirect-to-https\\"
        },
        \\"default_root_object\\": \\"index.html\\",
        \\"enabled\\": true,
        \\"origin\\": [
          {
            \\"domain_name\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket_regional_domain_name}\\",
            \\"origin_id\\": \\"s3Origin\\"
          }
        ],
        \\"price_class\\": \\"PriceClass_100\\",
        \\"restrictions\\": {
          \\"geo_restriction\\": {
            \\"locations\\": [],
            \\"restriction_type\\": \\"none\\"
          }
        },
        \\"viewer_certificate\\": {
          \\"cloudfront_default_certificate\\": true
        }
      }
    },
    \\"aws_s3_bucket\\": {
      \\"root_Website_WebsiteBucket_B334706B\\": {
        \\"bucket_prefix\\": \\"website-c80d509a-\\",
        \\"force_destroy\\": false
      }
    },
    \\"aws_s3_bucket_policy\\": {
      \\"root_Website_PublicPolicy_F4A65951\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"policy\\": \\"{\\\\\\"Version\\\\\\":\\\\\\"2012-10-17\\\\\\",\\\\\\"Statement\\\\\\":[{\\\\\\"Effect\\\\\\":\\\\\\"Allow\\\\\\",\\\\\\"Principal\\\\\\":\\\\\\"*\\\\\\",\\\\\\"Action\\\\\\":[\\\\\\"s3:GetObject\\\\\\"],\\\\\\"Resource\\\\\\":[\\\\\\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.arn}/*\\\\\\"]}]}\\"
      }
    },
    \\"aws_s3_bucket_server_side_encryption_configuration\\": {
      \\"root_Website_Encryption_3BFF2396\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"rule\\": [
          {
            \\"apply_server_side_encryption_by_default\\": {
              \\"sse_algorithm\\": \\"AES256\\"
            }
          }
        ]
      }
    },
    \\"aws_s3_bucket_website_configuration\\": {
      \\"root_Website_BucketWebsiteConfiguration_9BCFE685\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"index_document\\": {
          \\"suffix\\": \\"index.html\\"
        }
      }
    },
    \\"aws_s3_object\\": {
      \\"root_Website_FilebasenamepathsuffixifsuffixundefinedvalidateStringsuffixextvalidateStringpathpathletstart0letend1letmatchedSlashtrueifsuffixundefinedsuffixlength0suffixlengthpathlengthifsuffixpathreturnletextIdxsuffixlength1letfirstNonSlash_17CA2583\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"content_type\\": \\"text/html; charset=utf-8\\",
        \\"depends_on\\": [
          \\"aws_s3_bucket.root_Website_WebsiteBucket_B334706B\\"
        ],
        \\"key\\": \\"/b.html\\",
        \\"source\\": \\"<source>\\"
      },
      \\"root_Website_FilebasenamepathsuffixifsuffixundefinedvalidateStringsuffixextvalidateStringpathpathletstart0letend1letmatchedSlashtrueifsuffixundefinedsuffixlength0suffixlengthpathlengthifsuffixpathreturnletextIdxsuffixlength1letfirstNonSlash_2B591C83\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"content_type\\": \\"text/html; charset=utf-8\\",
        \\"depends_on\\": [
          \\"aws_s3_bucket.root_Website_WebsiteBucket_B334706B\\"
        ],
        \\"key\\": \\"/inner-folder/a.html\\",
        \\"source\\": \\"<source>\\"
      }
    }
  }
}"
`;

exports[`default website behavior 2`] = `
{
  "tree": {
    "children": {
      "root": {
        "children": {
          "Default": {
            "children": {
              "Website": {
                "attributes": {
                  "wing:resource:connections": [],
                  "wing:resource:stateful": false,
                },
                "children": {
                  "BucketWebsiteConfiguration": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3BucketWebsiteConfiguration.S3BucketWebsiteConfiguration",
                      "version": "12.0.2",
                    },
                    "id": "BucketWebsiteConfiguration",
                    "path": "root/Default/Website/BucketWebsiteConfiguration",
                  },
                  "Distribution": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.cloudfrontDistribution.CloudfrontDistribution",
                      "version": "12.0.2",
                    },
                    "id": "Distribution",
                    "path": "root/Default/Website/Distribution",
                  },
                  "Encryption": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3BucketServerSideEncryptionConfiguration.S3BucketServerSideEncryptionConfigurationA",
                      "version": "12.0.2",
                    },
                    "id": "Encryption",
                    "path": "root/Default/Website/Encryption",
                  },
                  "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-8cb79062": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3Object.S3Object",
                      "version": "12.0.2",
                    },
                    "id": "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-8cb79062",
                    "path": "root/Default/Website/File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-8cb79062",
                  },
                  "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-d1bb8b58": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3Object.S3Object",
                      "version": "12.0.2",
                    },
                    "id": "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-d1bb8b58",
                    "path": "root/Default/Website/File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-d1bb8b58",
                  },
                  "PublicPolicy": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3BucketPolicy.S3BucketPolicy",
                      "version": "12.0.2",
                    },
                    "id": "PublicPolicy",
                    "path": "root/Default/Website/PublicPolicy",
                  },
                  "WebsiteBucket": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3Bucket.S3Bucket",
                      "version": "12.0.2",
                    },
                    "id": "WebsiteBucket",
                    "path": "root/Default/Website/WebsiteBucket",
                  },
                },
                "constructInfo": {
                  "fqn": "constructs.Construct",
                  "version": "10.1.245",
                },
                "display": {
                  "description": "A static website",
                  "title": "Website",
                },
                "id": "Website",
                "path": "root/Default/Website",
              },
              "aws": {
                "constructInfo": {
                  "fqn": "@cdktf/provider-aws.provider.AwsProvider",
                  "version": "12.0.2",
                },
                "id": "aws",
                "path": "root/Default/aws",
              },
              "cloud.TestRunner": {
                "attributes": {
                  "wing:resource:connections": [],
                  "wing:resource:stateful": false,
                },
                "children": {
                  "TestFunctionArns": {
                    "constructInfo": {
                      "fqn": "cdktf.TerraformOutput",
                      "version": "0.15.2",
                    },
                    "id": "TestFunctionArns",
                    "path": "root/Default/cloud.TestRunner/TestFunctionArns",
                  },
                },
                "constructInfo": {
                  "fqn": "constructs.Construct",
                  "version": "10.1.245",
                },
                "display": {
                  "description": "A suite of APIs for running tests and collecting results.",
                  "hidden": true,
                  "title": "TestRunner",
                },
                "id": "cloud.TestRunner",
                "path": "root/Default/cloud.TestRunner",
              },
            },
            "constructInfo": {
              "fqn": "constructs.Construct",
              "version": "10.1.245",
            },
            "id": "Default",
            "path": "root/Default",
          },
          "backend": {
            "constructInfo": {
              "fqn": "cdktf.LocalBackend",
              "version": "0.15.2",
            },
            "id": "backend",
            "path": "root/backend",
          },
        },
        "constructInfo": {
          "fqn": "cdktf.TerraformStack",
          "version": "0.15.2",
        },
        "id": "root",
        "path": "root",
      },
    },
    "constructInfo": {
      "fqn": "cdktf.App",
      "version": "0.15.2",
    },
    "id": "App",
    "path": "",
  },
  "version": "tree-0.1",
}
`;

exports[`website with add_json 1`] = `
"{
  \\"output\\": {
    \\"WING_TEST_RUNNER_FUNCTION_ARNS\\": {
      \\"value\\": \\"[]\\"
    }
  },
  \\"resource\\": {
    \\"aws_cloudfront_distribution\\": {
      \\"root_Website_Distribution_02AE6540\\": {
        \\"default_cache_behavior\\": {
          \\"allowed_methods\\": [
            \\"GET\\",
            \\"HEAD\\"
          ],
          \\"cached_methods\\": [
            \\"GET\\",
            \\"HEAD\\"
          ],
          \\"compress\\": true,
          \\"default_ttl\\": 3600,
          \\"forwarded_values\\": {
            \\"cookies\\": {
              \\"forward\\": \\"none\\"
            },
            \\"query_string\\": false
          },
          \\"max_ttl\\": 86400,
          \\"min_ttl\\": 0,
          \\"target_origin_id\\": \\"s3Origin\\",
          \\"viewer_protocol_policy\\": \\"redirect-to-https\\"
        },
        \\"default_root_object\\": \\"index.html\\",
        \\"enabled\\": true,
        \\"origin\\": [
          {
            \\"domain_name\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket_regional_domain_name}\\",
            \\"origin_id\\": \\"s3Origin\\"
          }
        ],
        \\"price_class\\": \\"PriceClass_100\\",
        \\"restrictions\\": {
          \\"geo_restriction\\": {
            \\"locations\\": [],
            \\"restriction_type\\": \\"none\\"
          }
        },
        \\"viewer_certificate\\": {
          \\"cloudfront_default_certificate\\": true
        }
      }
    },
    \\"aws_s3_bucket\\": {
      \\"root_Website_WebsiteBucket_B334706B\\": {
        \\"bucket_prefix\\": \\"website-c80d509a-\\",
        \\"force_destroy\\": false
      }
    },
    \\"aws_s3_bucket_policy\\": {
      \\"root_Website_PublicPolicy_F4A65951\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"policy\\": \\"{\\\\\\"Version\\\\\\":\\\\\\"2012-10-17\\\\\\",\\\\\\"Statement\\\\\\":[{\\\\\\"Effect\\\\\\":\\\\\\"Allow\\\\\\",\\\\\\"Principal\\\\\\":\\\\\\"*\\\\\\",\\\\\\"Action\\\\\\":[\\\\\\"s3:GetObject\\\\\\"],\\\\\\"Resource\\\\\\":[\\\\\\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.arn}/*\\\\\\"]}]}\\"
      }
    },
    \\"aws_s3_bucket_server_side_encryption_configuration\\": {
      \\"root_Website_Encryption_3BFF2396\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"rule\\": [
          {
            \\"apply_server_side_encryption_by_default\\": {
              \\"sse_algorithm\\": \\"AES256\\"
            }
          }
        ]
      }
    },
    \\"aws_s3_bucket_website_configuration\\": {
      \\"root_Website_BucketWebsiteConfiguration_9BCFE685\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"index_document\\": {
          \\"suffix\\": \\"index.html\\"
        }
      }
    },
    \\"aws_s3_object\\": {
      \\"root_Website_FilebasenamepathsuffixifsuffixundefinedvalidateStringsuffixextvalidateStringpathpathletstart0letend1letmatchedSlashtrueifsuffixundefinedsuffixlength0suffixlengthpathlengthifsuffixpathreturnletextIdxsuffixlength1letfirstNonSlash_17CA2583\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"content_type\\": \\"text/html; charset=utf-8\\",
        \\"depends_on\\": [
          \\"aws_s3_bucket.root_Website_WebsiteBucket_B334706B\\"
        ],
        \\"key\\": \\"/b.html\\",
        \\"source\\": \\"<source>\\"
      },
      \\"root_Website_FilebasenamepathsuffixifsuffixundefinedvalidateStringsuffixextvalidateStringpathpathletstart0letend1letmatchedSlashtrueifsuffixundefinedsuffixlength0suffixlengthpathlengthifsuffixpathreturnletextIdxsuffixlength1letfirstNonSlash_2B591C83\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"content_type\\": \\"text/html; charset=utf-8\\",
        \\"depends_on\\": [
          \\"aws_s3_bucket.root_Website_WebsiteBucket_B334706B\\"
        ],
        \\"key\\": \\"/inner-folder/a.html\\",
        \\"source\\": \\"<source>\\"
      },
      \\"root_Website_Fileconfigjson_49B1EFB1\\": {
        \\"bucket\\": \\"\${aws_s3_bucket.root_Website_WebsiteBucket_B334706B.bucket}\\",
        \\"content\\": \\"{\\\\\\"version\\\\\\":\\\\\\"8.31.0\\\\\\"}\\",
        \\"content_type\\": \\"application/json\\",
        \\"depends_on\\": [
          \\"aws_s3_bucket.root_Website_WebsiteBucket_B334706B\\"
        ],
        \\"key\\": \\"config.json\\"
      }
    }
  }
}"
`;

exports[`website with add_json 2`] = `
{
  "tree": {
    "children": {
      "root": {
        "children": {
          "Default": {
            "children": {
              "Website": {
                "attributes": {
                  "wing:resource:connections": [],
                  "wing:resource:stateful": false,
                },
                "children": {
                  "BucketWebsiteConfiguration": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3BucketWebsiteConfiguration.S3BucketWebsiteConfiguration",
                      "version": "12.0.2",
                    },
                    "id": "BucketWebsiteConfiguration",
                    "path": "root/Default/Website/BucketWebsiteConfiguration",
                  },
                  "Distribution": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.cloudfrontDistribution.CloudfrontDistribution",
                      "version": "12.0.2",
                    },
                    "id": "Distribution",
                    "path": "root/Default/Website/Distribution",
                  },
                  "Encryption": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3BucketServerSideEncryptionConfiguration.S3BucketServerSideEncryptionConfigurationA",
                      "version": "12.0.2",
                    },
                    "id": "Encryption",
                    "path": "root/Default/Website/Encryption",
                  },
                  "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-8cb79062": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3Object.S3Object",
                      "version": "12.0.2",
                    },
                    "id": "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-8cb79062",
                    "path": "root/Default/Website/File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-8cb79062",
                  },
                  "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-d1bb8b58": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3Object.S3Object",
                      "version": "12.0.2",
                    },
                    "id": "File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-d1bb8b58",
                    "path": "root/Default/Website/File-basename(path, suffix) {
    if (suffix !== undefined)
      validateString(suffix, 'ext');
    validateString(path, 'path');

    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
      if (suffix === path)
        return '';
      let extIdx = suffix.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = StringPrototypeCharCodeAt(path, i);
        if (code === CHAR_FORWARD_SLASH) {
          ---- If we reached a path separator that was not part of a set of path
          ---- separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            ---- We saw the first non-path separator, remember this index in case
            ---- we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            ---- Try to match the explicit extension
            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {
              if (--extIdx === -1) {
                ---- We matched the extension, so mark this as the end of our path
                ---- component
                end = i;
              }
            } else {
              ---- Extension does not match, so our result is the entire path
              ---- component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return StringPrototypeSlice(path, start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {
        ---- If we reached a path separator that was not part of a set of path
        ---- separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        ---- We saw the first non-path separator, mark this as the end of our
        ---- path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return StringPrototypeSlice(path, start, end);
  }-d1bb8b58",
                  },
                  "File-config.json": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3Object.S3Object",
                      "version": "12.0.2",
                    },
                    "id": "File-config.json",
                    "path": "root/Default/Website/File-config.json",
                  },
                  "PublicPolicy": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3BucketPolicy.S3BucketPolicy",
                      "version": "12.0.2",
                    },
                    "id": "PublicPolicy",
                    "path": "root/Default/Website/PublicPolicy",
                  },
                  "WebsiteBucket": {
                    "constructInfo": {
                      "fqn": "@cdktf/provider-aws.s3Bucket.S3Bucket",
                      "version": "12.0.2",
                    },
                    "id": "WebsiteBucket",
                    "path": "root/Default/Website/WebsiteBucket",
                  },
                },
                "constructInfo": {
                  "fqn": "constructs.Construct",
                  "version": "10.1.245",
                },
                "display": {
                  "description": "A static website",
                  "title": "Website",
                },
                "id": "Website",
                "path": "root/Default/Website",
              },
              "aws": {
                "constructInfo": {
                  "fqn": "@cdktf/provider-aws.provider.AwsProvider",
                  "version": "12.0.2",
                },
                "id": "aws",
                "path": "root/Default/aws",
              },
              "cloud.TestRunner": {
                "attributes": {
                  "wing:resource:connections": [],
                  "wing:resource:stateful": false,
                },
                "children": {
                  "TestFunctionArns": {
                    "constructInfo": {
                      "fqn": "cdktf.TerraformOutput",
                      "version": "0.15.2",
                    },
                    "id": "TestFunctionArns",
                    "path": "root/Default/cloud.TestRunner/TestFunctionArns",
                  },
                },
                "constructInfo": {
                  "fqn": "constructs.Construct",
                  "version": "10.1.245",
                },
                "display": {
                  "description": "A suite of APIs for running tests and collecting results.",
                  "hidden": true,
                  "title": "TestRunner",
                },
                "id": "cloud.TestRunner",
                "path": "root/Default/cloud.TestRunner",
              },
            },
            "constructInfo": {
              "fqn": "constructs.Construct",
              "version": "10.1.245",
            },
            "id": "Default",
            "path": "root/Default",
          },
          "backend": {
            "constructInfo": {
              "fqn": "cdktf.LocalBackend",
              "version": "0.15.2",
            },
            "id": "backend",
            "path": "root/backend",
          },
        },
        "constructInfo": {
          "fqn": "cdktf.TerraformStack",
          "version": "0.15.2",
        },
        "id": "root",
        "path": "root",
      },
    },
    "constructInfo": {
      "fqn": "cdktf.App",
      "version": "0.15.2",
    },
    "id": "App",
    "path": "",
  },
  "version": "tree-0.1",
}
`;
